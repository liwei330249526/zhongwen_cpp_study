//read
//为什么要以全局函数的形式重载 +
//我们定义的operator+是一个全局函数（一个友元函数），而不是成员函数，这样做是为了保证 + 运算符的操作数能够被对称的处理；
// 换句话说，小数（double 类型）在 + 左边和右边都是正确的。第 30 行代码中，15.6 在 + 的右边，第 31 行代码中，28.23 在 + 的左边，
// 它们都能够被顺利地转换为 Complex 类型，所以不会出错

//如果将operator+定义为成员函数，根据“+ 运算符具有左结合性”这条原则，Complex c2 = c1 + 15.6;会被转换为下面的形式：
//Complex c2 = c1.operator+(Complex(15.6));
//这就是通过对象调用成员函数，是正确的。

//而对于Complex c3 = 28.23 + c1;
//编译器会尝试转换为不同的形式：
//Complex c3 = (28.23).operator+(c1);
//很显然这是错误的，因为 double 类型并没有以成员函数的形式重载 +。

//也就是说，以成员函数的形式重载 +，只能计算c1 + 15.6，不能计算28.23 + c1，这是不对称的

//有读者可能会问，编译器明明可以把 28.23 先转换成 Complex 类型再相加呀，也就是下面的形式：
//Complex c3 = Complex(28.23).operator+(c1);

//为什么就是不转换呢？没错，编译器不会转换，原因在于，C++ 只会对成员函数的参数进行类型转换，而不会对调用成员函数的对象进行类型转换。以下面的语句为例：
//obj.func(params);
//
//编译器不会尝试对 obj 进行任何类型转换，它有 func() 成员函数就调用，没有就报错。而对于实参 params，编译器会“拼命地”将它转换为形参的类型。




//为什么要以成员函数的形式重载 +=
//我们首先要明白，运算符重载的初衷是给类添加新的功能，方便类的运算，它作为类的成员函数是理所应当的，是首选的。

//采用全局函数能使我们定义这样的运算符，它们的参数具有逻辑的对称性。与此相对应的，
// 把运算符定义为成员函数能够保证在调用时对第一个（最左的）运算对象不出现类型转换，也就是上面提到的「C++ 不会对调用成员函数的对象进行类型转换」。


//总起来说，有一部分运算符重载既可以是成员函数也可以是全局函数，虽然没有一个必然的、不可抗拒的理由选择成员函数，
// 但我们应该优先考虑成员函数，这样更符合运算符重载的初衷；
// 另外有一部分运算符重载必须是全局函数，这样能保证参数的对称性；除了 C++ 规定的几个特定的运算符外，暂时还没有发现必须以成员函数的形式重载的运算符。

//C++ 规定，箭头运算符->、下标运算符[ ]、函数调用运算符( )、赋值运算符=只能以成员函数的形式重载。