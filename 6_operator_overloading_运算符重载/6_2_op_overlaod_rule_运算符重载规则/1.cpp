// read
//1) 并不是所有的运算符都可以重载。
//[]是下标运算符，()是函数调用运算符。自增自减运算符的前置和后置形式都可以重载。长度运算符sizeof、条件运算符: ?、成员选择符.和域解析运算符::不能被重载。
//
//2) 重载不能改变运算符的优先级和结合性。
//
//3) 重载不会改变运算符的用法，原有有几个操作数、操作数在左边还是在右边，这些都不会改变。例如~号右边只有一个操作数，+号总是出现在两个操作数之间，重载后也必须如此。
//
//4) 运算符重载函数不能有默认的参数，否则就改变了运算符操作数的个数，这显然是错误的。
//
//5) 运算符重载函数既可以作为类的成员函数，也可以作为全局函数。
//将运算符重载函数作为类的成员函数时，二元运算符的参数只有一个，一元运算符不需要参数。之所以少一个参数，是因为这个参数是隐含的。
//例如，上节的 complex 类中重载了加法运算符：
//complex operator+(const complex & A) const;
//
//当执行：
//c3 = c1 + c2;
//
//会被转换为：
//c3 = c1.operator+(c2);
//
//将运算符重载函数作为全局函数时，二元操作符就需要两个参数，一元操作符需要一个参数，而且其中必须有一个参数是对象，
//好让编译器区分这是程序员自定义的运算符，防止程序员修改用于内置类型的运算符的性质。
//
//6) 箭头运算符->、下标运算符[ ]、函数调用运算符( )、赋值运算符=只能以成员函数的形式重载。