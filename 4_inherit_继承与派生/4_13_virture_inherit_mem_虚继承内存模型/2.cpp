//https://c.biancheng.net/view/vip_2282.html

//cfront解决方案
//早期的 cfront 编译器会在派生类对象中安插一些指针，每个指针指向一个虚基类的子对象，要存取继承来的成员变量，可以使用指针间接完成。

//如果 A 是 B 的虚基类，同时 B 也是 C 的虚基类
//则C的对象中有一个指针 *pb 指向虚基类B的起始位置， B的内存中一个指针 *pa 指向虚基类A的起始位置.

// 问题1， 继承越深，通过指针间接转换越多。
// 问题2， 多继承， 对象体积变大

//VC的解决方案
//VC 引入了虚基类表，如果某个派生类有一个或多个虚基类，编译器就会在派生类对象中安插一个指针，指向虚基类表。
// 虚基类表其实就是一个数组，数组中的元素存放的是各个虚基类的偏移。

//虚继承表中保存的是所有虚基类（包括直接继承和间接继承到的）相对于当前对象的偏移，
// 这样通过派生类指针访问虚基类的成员变量时，不管继承层次都多深，只需要一次间接转换就可以。

//另外，这种方案还可以避免有多个虚基类时让派生类对象额外背负过多的指针