class A{
protected:
    int m_a1;
    int m_a2;
};

class B: public A{
protected:
    int b1;
    int b2;
};

class C: public B{
protected:
    int c1;
    int c2;
};

class D: public C{
protected:
    int d1;
    int d2;
};

int main(){
  A obj_a;
  B obj_b;
  C obj_c;
  D obj_d;

  return 0;
}
//
//obj_d
//a1
//a2
//b1
//b2
//c1
//c2
//d1
//d2




// read
//对于普通继承，基类子对象始终位于派生类对象的前面（也即基类成员变量始终在派生类成员变量的前面），
// 而且不管继承层次有多深，它相对于派生类对象顶部的偏移量是固定的。


//前面我们说过，编译器在知道对象首地址的情况下，通过计算偏移来存取成员变量。
// 对于普通继承，基类成员变量的偏移是固定的，不会随着继承层级的增加而改变，存取起来非常方便。


//1) 修改上面的代码，使得 A 是 B 的虚基类：
//class B: virtual public A


//而对于虚继承，恰恰和普通继承相反，大部分编译器会把基类成员变量放在派生类成员变量的后面，
// 这样随着继承层级的增加，基类成员变量的偏移就会改变，就得通过其他方案来计算偏移量。
//obj_d
//b1
//b2
//c1
//c2
//d1
//d2
//a1
//a2

//2) 再假设 A 是 B 的虚基类，B 又是 C 的虚基类，那么各个对象的内存模型如下图所示：
//obj_d
//c1  向下时固定部分
//c2
//d1
//d2
//a1   向下时共享部分
//a2
//b1
//b2



//当要访问对象的成员变量时，需要知道对象的首地址和变量的偏移，对象的首地址很好获得，关键是变量的偏移。
// 对于固定部分，偏移是不变的，很好计算；而对于共享部分，偏移会随着继承层次的增加而改变
