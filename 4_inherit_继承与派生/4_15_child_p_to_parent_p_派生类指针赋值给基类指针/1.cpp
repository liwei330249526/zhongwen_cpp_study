#include <iostream>
using namespace std;

int main(){
  double pi = 3.14159;
  int n = pi;
  cout<<pi<<", "<<n<<endl;
  return 0;
}
//3.14159, 3

//pi 的值是 3.14159，执行int n = pi;后 n 的值变为 3，虽然是赋值，但是 pi 和 n 的值并不相等。

//read
//通过上节最后一个例子我们发现，将派生类的指针赋值给基类的指针后，它们的值有可能相等，也有可能不相等

//我们通常认为，赋值就是将一个变量的值交给另外一个变量，这种想法虽然没错，但是有一点要注意，
// 就是赋值以前编译器可能会对现有的值进行处理。例如将 double 类型的值赋给 int 类型的变量，编译器会直接抹掉小数部分，
// 导致赋值运算符两边变量的值不相等。

//将派生类的指针赋值给基类的指针时也是类似的道理，编译器也可能会在赋值前进行处理。
/*
 *  https://c.biancheng.net/view/2285.html
 *
 * class D: public B, public C
 * m_a
 * m_b
 * m_c
 * m_d
 *
 *
 *
 * class D: public B, public C
 * m_c
 * m_a
 * m_b
 * m_d
 * */
//首先要明确的一点是，对象的指针必须要指向对象的起始位置。对于 A 类和 B 类来说，它们的子对象的起始地址和 D 类对象一样，
//所以将 pd 赋值给 pa、pb 时不需要做任何调整，直接传递现有的值即可；而 C 类子对象距离 D 类对象的开头有一定的偏移，
//将 pd 赋值给 pc 时要加上这个偏移，这样 pc 才能指向 C 类子对象的起始位置。也就是说，执行pc = pd;
//语句时编译器对 pd 的值进行了调整，才导致 pc、pd 的值不同。
//
//下面的代码演示了将 pd 赋值给 pc 时编译器的调整过程：
//pc = (C*)( (int)pd + sizeof(B) );