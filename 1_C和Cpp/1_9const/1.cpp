//在C语言中，const  用来限制一个变量，表示这个变量不能被修改，我们通常称这样的变量为常量（Constant）

//先来看下面的两条语句：
//const int m = 10;
//int n = m;
//
//在C语言中，编译器会先到 m 所在的内存取出一份数据，再将这份数据赋给 n；而在C++中，
//编译器会直接将 10 赋给 n，没有读取内存的过程，和int n = 10;的效果一样

//C++ 对 const 的处理少了读取内存的过程，优点是提高了程序执行效率，缺点是不能反映内存的变化，
//一旦 const 变量被修改，C++ 就不能取得最新的值。

#include <stdio.h>
int main(){
    const int n = 10;
    int *p = (int*)&n;  //必须强制类型转换
    *p = 99;  //修改const变量的值
    printf("%d\n", n);
    return 0;
}

//10

//const 变量不是禁止被修改吗？对，这种说法没错！不过这只是语法层面上的限制，通过指针仍然可以修改

//将代码放到.c文件中，以C语言的方式编译，运行结果为99。再将代码放到.cpp文件中，
//以C++的方式编译，运行结果就变成了10。这种差异正是由于C和C++对 const 的处理方式不同造成的。


//在C语言中，使用 printf 输出 n 时会到内存中获取 n 的值，
//这个时候 n 所在内存中的数据已经被修改成了 99，所以输出结果也是 99。
//而在C++中，printf("%d\n", n);语句在编译时就将 n 的值替换成了 10，
//效果和printf("%d\n", 10);一样，不管 n 所在的内存如何变化，都不会影响输出结果。

//这种修改常量的变态代码在实际开发中基本不会出现，
// 本例只是为了说明C和C++对 const 的处理方式的差异：
// C语言对 const 的处理和普通变量一样，会到内存中读取数据；
// C++ 对 const 的处理更像是编译时期的#define，是一个值替换的过程